package de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.ui.controller;

import com.vaadin.spring.annotation.SpringComponent;
import com.vaadin.spring.annotation.UIScope;

import de.muenchen.eventbus.EventBus;
import de.muenchen.eventbus.events.Association;
import de.muenchen.eventbus.selector.entity.RequestEntityKey;
import de.muenchen.eventbus.selector.entity.RequestEvent;
import de.muenchen.eventbus.selector.entity.ResponseEntityKey;

import de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.services.Buerger_Service;
import de.muenchen.kvr.buergerverwaltung.buerger.client.local.Buerger_;
import de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.services.Pass_Service;
import de.muenchen.kvr.buergerverwaltung.buerger.client.local.Pass_;
import de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.services.Sachbearbeiter_Service;
import de.muenchen.kvr.buergerverwaltung.buerger.client.local.Sachbearbeiter_;
import de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.services.Wohnung_Service;
import de.muenchen.kvr.buergerverwaltung.buerger.client.local.Wohnung_;
import de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.services.model.Buerger_Datastore;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.hateoas.ResourceSupport;
import org.springframework.hateoas.Link;
import reactor.bus.Event;

import javax.annotation.PostConstruct;
import java.io.Serializable;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import de.muenchen.vaadin.guilib.BaseUI;

/*
 * This file will be overwritten on every change of the model!
 * This file was automatically generated by GAIA.
 */
@SpringComponent
@UIScope
public class Buerger_ViewController implements Serializable{

	private static final long serialVersionUID = 1L;
	
	/**
	 * Logger
	 */
	private static final Logger LOG = LoggerFactory.getLogger(Buerger_ViewController.class);
	
	/**
	 * Die Buerger_Service Klasse
	 */
	@Autowired
	Buerger_Service buergerService;
	
	/**
	 * Die Pass_Service Klasse
	 */
	@Autowired
	Pass_Service passService;
	
	/**
	 * Die Sachbearbeiter_Service Klasse
	 */
	@Autowired
	Sachbearbeiter_Service sachbearbeiterService;
	
	/**
	 * Die Wohnung_Service Klasse
	 */
	@Autowired
	Wohnung_Service wohnungService;
	
	private final Buerger_Datastore model = new Buerger_Datastore();
	

	@PostConstruct
	private void init() {
		initEventhandlers();
	}
	
	private EventBus getEventbus() {
        return BaseUI.getCurrentEventBus();
    }
	
	public Buerger_Datastore getModel() {
		return model;
	}

	////////////////////////
	// Service Operations //
	////////////////////////

	/**
	 * Speichert ein {@link Buerger_} Objekt in der Datenbank.
	 *
	 * @param buerger Buerger_ der gespeichert werden soll
	 */
	public Buerger_ save(Buerger_ buerger) {
		return buergerService.create(buerger);
	}

	/**
	 * Zerstört die Verbindung zwischen einem Buerger_ und seinem kinder
	 *
	 * @param event
	 */
	private void releaseKinder(Buerger_ event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.kinder.name());
		List<Link> kinder = buergerService.findAll(link)
				.stream()
				.map(Buerger_::getId)
				.filter(id -> !id.equals(event.getId()))
				.collect(Collectors.toList());

		buergerService.setRelations(link, kinder);
	}
	
	/**
	 * Zerstört die Verbindung zwischen einem Buerger_ und seinen kinder
	 *
	 * @param event
	 */
	private void releaseKinderList(List<Buerger_> event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.kinder.name());
		
		List<Link> eventLinks = event.stream().map(ResourceSupport::getId).collect(Collectors.toList());
		
		List<Link> relations = buergerService.findAll(link)
				.stream()
				.map(Buerger_::getId)
				.filter(id -> !eventLinks.contains(id))
				.collect(Collectors.toList());
		
		buergerService.setRelations(link, relations);
	}
	
	/**
	 * Speichert eine beziehung als kinder zu einem {@link Buerger_} Objekt in der Datenbank.
	 *
	 * @param kinderEntity Kinder
	 * @return Buerger_
	 */
	public void addBuergerKinder(Buerger_ kinderEntity) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.kinder.name());
		List<Link> kinderlist = Stream.concat(
				buergerService.findAll(link)
						.stream()
						.map(Buerger_::getId),
				Stream.of(kinderEntity.getId()))
	
				.collect(Collectors.toList());
	
		buergerService.setRelations(link, kinderlist);
	}
	
	public List<Buerger_> queryKinder(Buerger_ entity) {
		return buergerService.findAll(entity.getLink(Buerger_.Rel.kinder.name())).stream().collect(Collectors.toList());
	}
	
	/**
	 * Speichert Beziehungen als kinder zu einem {@link Buerger_} Objekt in der Datenbank.
	 *
	 * @param event Attributes
	 */
	public void addBuergerKinderList(List<Buerger_> event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.kinder.name());
		
		List<Link> eventLinks = event.stream().map(ResourceSupport::getId).collect(Collectors.toList());
		
		List<Link> relations = Stream.concat(
		buergerService.findAll(link)
				.stream()
				.map(Buerger_::getId)
				.filter(link1 -> !eventLinks.contains(link1)),
		
		eventLinks.stream())
				.collect(Collectors.toList());
		
		buergerService.setRelations(link, relations);
	}

	/**
	 * Vernichted die Verbindung zwischen einem Buerger_ und seinem partner
	 *
	 * @param event
	 */
	private void releasePartner(Buerger_ event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.partner.name());
		buergerService.setRelation(link,null);
	}
	
	/**
	 * Speichert eine Beziehung als Partner zu einem {@link Buerger_} Objekt in der Datenbank.
	 *
	 * @param partnerEntity Partner
	 * @return Buerger_
	 */
	public void setBuergerPartner(Buerger_ partnerEntity) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.partner.name());
		buergerService.setRelation(link, partnerEntity.getId());
	}
	
	public Buerger_ queryPartner(Buerger_ entity) {
		return buergerService.findOne(entity.getLink(Buerger_.Rel.partner.name())).orElse(null);
	}
	

	/**
	 * Vernichted die Verbindung zwischen einem Buerger_ und seinem pass
	 *
	 * @param event
	 */
	private void releasePass(Pass_ event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.pass.name());
		buergerService.setRelation(link,null);
	}
	
	/**
	 * Speichert eine Beziehung als Pass zu einem {@link Pass_} Objekt in der Datenbank.
	 *
	 * @param passEntity Pass
	 * @return Buerger_
	 */
	public void setBuergerPass(Pass_ passEntity) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.pass.name());
		passService.setRelation(link, passEntity.getId());
	}
	
	public Pass_ queryPass(Buerger_ entity) {
		return passService.findOne(entity.getLink(Buerger_.Rel.pass.name())).orElse(null);
	}
	

	/**
	 * Zerstört die Verbindung zwischen einem Buerger_ und seinem sachbearbeiter
	 *
	 * @param event
	 */
	private void releaseSachbearbeiter(Sachbearbeiter_ event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.sachbearbeiter.name());
		List<Link> sachbearbeiter = sachbearbeiterService.findAll(link)
				.stream()
				.map(Sachbearbeiter_::getId)
				.filter(id -> !id.equals(event.getId()))
				.collect(Collectors.toList());

		buergerService.setRelations(link, sachbearbeiter);
	}
	
	/**
	 * Zerstört die Verbindung zwischen einem Buerger_ und seinen sachbearbeiter
	 *
	 * @param event
	 */
	private void releaseSachbearbeiterList(List<Sachbearbeiter_> event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.sachbearbeiter.name());
		
		List<Link> eventLinks = event.stream().map(ResourceSupport::getId).collect(Collectors.toList());
		
		List<Link> relations = sachbearbeiterService.findAll(link)
				.stream()
				.map(Sachbearbeiter_::getId)
				.filter(id -> !eventLinks.contains(id))
				.collect(Collectors.toList());
		
		buergerService.setRelations(link, relations);
	}
	
	/**
	 * Speichert eine beziehung als sachbearbeiter zu einem {@link Sachbearbeiter_} Objekt in der Datenbank.
	 *
	 * @param sachbearbeiterEntity Sachbearbeiter
	 * @return Sachbearbeiter_
	 */
	public void addBuergerSachbearbeiter(Sachbearbeiter_ sachbearbeiterEntity) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.sachbearbeiter.name());
		List<Link> sachbearbeiterlist = Stream.concat(
				sachbearbeiterService.findAll(link)
						.stream()
						.map(Sachbearbeiter_::getId),
				Stream.of(sachbearbeiterEntity.getId()))
	
				.collect(Collectors.toList());
	
		buergerService.setRelations(link, sachbearbeiterlist);
	}
	
	public List<Sachbearbeiter_> querySachbearbeiter(Buerger_ entity) {
		return sachbearbeiterService.findAll(entity.getLink(Buerger_.Rel.sachbearbeiter.name())).stream().collect(Collectors.toList());
	}
	
	/**
	 * Speichert Beziehungen als sachbearbeiter zu einem {@link Sachbearbeiter_} Objekt in der Datenbank.
	 *
	 * @param event Attributes
	 */
	public void addBuergerSachbearbeiterList(List<Sachbearbeiter_> event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.sachbearbeiter.name());
		
		List<Link> eventLinks = event.stream().map(ResourceSupport::getId).collect(Collectors.toList());
		
		List<Link> relations = Stream.concat(
		buergerService.findAll(link)
				.stream()
				.map(Buerger_::getId)
				.filter(link1 -> !eventLinks.contains(link1)),
		
		eventLinks.stream())
				.collect(Collectors.toList());
		
		buergerService.setRelations(link, relations);
	}

	/**
	 * Vernichted die Verbindung zwischen einem Buerger_ und seinem wohnungen
	 *
	 * @param event
	 */
	private void releaseWohnungen(Wohnung_ event) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.wohnungen.name());
		buergerService.setRelation(link,null);
	}
	
	/**
	 * Speichert eine Beziehung als Wohnungen zu einem {@link Wohnung_} Objekt in der Datenbank.
	 *
	 * @param wohnungenEntity Wohnungen
	 * @return Buerger_
	 */
	public void setBuergerWohnungen(Wohnung_ wohnungenEntity) {
		Link link = getModel().getSelectedBuerger().get().getLink(Buerger_.Rel.wohnungen.name());
		wohnungService.setRelation(link, wohnungenEntity.getId());
	}
	
	public Wohnung_ queryWohnungen(Buerger_ entity) {
		return wohnungService.findOne(entity.getLink(Buerger_.Rel.wohnungen.name())).orElse(null);
	}
	
	/**
	 * Speichert die Änderungen an einem {@link Buerger_} Objekt in der Datenbank.
	 *
	 * @param entity Buerger_
	 * @return Buerger_
	 */
	public Buerger_ updateBuerger(Buerger_ entity) {
		return buergerService.update(entity);
	}

	/**
	 * Löscht ein {@link Buerger_} Objekt.
	 *
	 * @param entity Buerger_
	 */
	public void deleteBuerger(Buerger_ entity) {
		buergerService.delete(entity.getId());
	}

	public List<Buerger_> queryBuerger() {
		return buergerService.findAll().stream().collect(Collectors.toList());
	}

	public List<Buerger_> queryBuerger(String query) {
		return buergerService.queryBuerger(query);
	}
	
	/////////////////////
	// Event Steuerung //
	/////////////////////

	/**
	 * Register all event handlers on the RequestEntityKey.
	 */
	private void initEventhandlers() {
		getEventbus().on(getRequestKey(RequestEvent.CREATE).toSelector(), this::create);
		getEventbus().on(getRequestKey(RequestEvent.DELETE).toSelector(), this::delete);	 
		getEventbus().on(getRequestKey(RequestEvent.UPDATE).toSelector(), this::update);
		getEventbus().on(getRequestKey(RequestEvent.ADD_ASSOCIATION).toSelector(), this::addAssociation);	 
		getEventbus().on(getRequestKey(RequestEvent.REMOVE_ASSOCIATION).toSelector(), this::removeAssociation);
		getEventbus().on(getRequestKey(RequestEvent.ADD_ASSOCIATIONS).toSelector(), this::addAssociations);
		getEventbus().on(getRequestKey(RequestEvent.REMOVE_ASSOCIATIONS).toSelector(), this::removeAssociations);
		getEventbus().on(getRequestKey(RequestEvent.READ_LIST).toSelector(), this::readList);
		getEventbus().on(getRequestKey(RequestEvent.READ_SELECTED).toSelector(), this::readSelected);
	}

	/**
	 * Remove the specified Association from the specified Relation and update the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Association} as {@link Event#getData()}.
	 */
	void removeAssociation(Event<?> event) {
		final Object data = event.getData();
		if (data == null)
			throw new NullPointerException("Event data must not be null!");
		if (data.getClass() != Association.class)
			throw new IllegalArgumentException("The event must be of " + Association.class);

		final Association<?> association = (Association<?>) event.getData();
		final Buerger_.Rel rel = Buerger_.Rel.valueOf(association.getRel());
		
		if (Buerger_.Rel.kinder == rel) {
			Buerger_ kinder = (Buerger_) association.getAssociation();
			releaseKinder(kinder);
			getModel().getSelectedBuergerKinder().removeItem(kinder);
		}
		if (Buerger_.Rel.partner == rel) {
			Buerger_ partner = (Buerger_) association.getAssociation();
			releasePartner(partner);
			getModel().setSelectedBuergerPartner(Optional.empty());
		}
		if (Buerger_.Rel.pass == rel) {
			Pass_ pass = (Pass_) association.getAssociation();
			releasePass(pass);
			getModel().setSelectedBuergerPass(Optional.empty());
		}
		if (Buerger_.Rel.sachbearbeiter == rel) {
			Sachbearbeiter_ sachbearbeiter = (Sachbearbeiter_) association.getAssociation();
			releaseSachbearbeiter(sachbearbeiter);
			getModel().getSelectedBuergerSachbearbeiter().removeItem(sachbearbeiter);
		}
		if (Buerger_.Rel.wohnungen == rel) {
			Wohnung_ wohnungen = (Wohnung_) association.getAssociation();
			releaseWohnungen(wohnungen);
			getModel().setSelectedBuergerWohnungen(Optional.empty());
		}
		notifyComponents();
	}

	/**
	 * Add the specified Association to the specified Relation and update the DataStore.
	 * <p>	 
	 * If the {@link Association#getAssociation()} has no {@link ResourceSupport#getId()} the Resouce will be created
	 * on the DataStore first.
	 * </p>
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Association} as {@link Event#getData()}.
	 */
	private void addAssociation(Event<?> event) {
		final Object data = event.getData();
		if (data == null) 
			throw new NullPointerException("Event data must not be null!");
		if (data.getClass() != Association.class)
			throw new IllegalArgumentException("The event must be of " + Association.class);

		final Association<?> association = (Association<?>) event.getData();

		final Buerger_.Rel rel = Buerger_.Rel.valueOf(association.getRel());
		if (Buerger_.Rel.kinder == rel) {
			Buerger_ kinder = (Buerger_) association.getAssociation();
			// If Kinder has no ID he has to be created in the backend
			if (kinder.getId() == null) {
				Class<?> clazz = association.getAssociation().getClass();
				if(clazz.equals(Buerger_.class)){
					kinder = buergerService.create((Buerger_)association.getAssociation());
				} else if(clazz.equals(Buerger_.class)){
					kinder = buergerService.create((Buerger_) association.getAssociation());
				} else{
					throw new IllegalArgumentException("Only classes \"? extends Buerger_\" allowed!");
				}
			}
			addBuergerKinder(kinder);
			getModel().getSelectedBuergerKinder().addBean(kinder);
		}
		if (Buerger_.Rel.partner == rel) {
			Buerger_ partner = (Buerger_) association.getAssociation();
			
			// If Partner has no ID he has to be created in the backend
			if (partner.getId() == null) {
				Class<?> clazz = association.getAssociation().getClass();
				if(clazz.equals(Buerger_.class)){
					partner = buergerService.create((Buerger_)association.getAssociation());
				} else if(clazz.equals(Buerger_.class)){
					partner = buergerService.create((Buerger_) association.getAssociation());
				} else{
					throw new IllegalArgumentException("Only classes \"? extends Buerger_\" allowed!");
				}
			}
			setBuergerPartner(partner);
			getModel().setSelectedBuergerPartner(Optional.of(partner));
		}
		if (Buerger_.Rel.pass == rel) {
			Pass_ pass = (Pass_) association.getAssociation();
			
			// If Pass has no ID he has to be created in the backend
			if (pass.getId() == null) {
				Class<?> clazz = association.getAssociation().getClass();
				if(clazz.equals(Pass_.class)){
					pass = passService.create((Pass_)association.getAssociation());
				} else if(clazz.equals(Pass_.class)){
					pass = passService.create((Pass_) association.getAssociation());
				} else{
					throw new IllegalArgumentException("Only classes \"? extends Pass_\" allowed!");
				}
			}
			setBuergerPass(pass);
			getModel().setSelectedBuergerPass(Optional.of(pass));
		}
		if (Buerger_.Rel.sachbearbeiter == rel) {
			Sachbearbeiter_ sachbearbeiter = (Sachbearbeiter_) association.getAssociation();
			// If Sachbearbeiter has no ID he has to be created in the backend
			if (sachbearbeiter.getId() == null) {
				Class<?> clazz = association.getAssociation().getClass();
				if(clazz.equals(Sachbearbeiter_.class)){
					sachbearbeiter = sachbearbeiterService.create((Sachbearbeiter_)association.getAssociation());
				} else if(clazz.equals(Sachbearbeiter_.class)){
					sachbearbeiter = sachbearbeiterService.create((Sachbearbeiter_) association.getAssociation());
				} else{
					throw new IllegalArgumentException("Only classes \"? extends Sachbearbeiter_\" allowed!");
				}
			}
			addBuergerSachbearbeiter(sachbearbeiter);
			getModel().getSelectedBuergerSachbearbeiter().addBean(sachbearbeiter);
		}
		if (Buerger_.Rel.wohnungen == rel) {
			Wohnung_ wohnungen = (Wohnung_) association.getAssociation();
			
			// If Wohnungen has no ID he has to be created in the backend
			if (wohnungen.getId() == null) {
				Class<?> clazz = association.getAssociation().getClass();
				if(clazz.equals(Wohnung_.class)){
					wohnungen = wohnungService.create((Wohnung_)association.getAssociation());
				} else if(clazz.equals(Wohnung_.class)){
					wohnungen = wohnungService.create((Wohnung_) association.getAssociation());
				} else{
					throw new IllegalArgumentException("Only classes \"? extends Wohnung_\" allowed!");
				}
			}
			setBuergerWohnungen(wohnungen);
			getModel().setSelectedBuergerWohnungen(Optional.of(wohnungen));
		}
		refreshModelAssociations();
		notifyComponents();
	}
	
	/**
	 * Remove the specified Associations from the specified Relation and update the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Association} as {@link Event#getData()}.
	 */
	@SuppressWarnings("unchecked")
	void removeAssociations(Event<?> event) {
		final Object data = event.getData();
		if (data == null)
			throw new NullPointerException("Event data must not be null!");
		if (!(data instanceof List))
			throw new IllegalArgumentException("The event must be of " + List.class);
		
		final List<?> dataList = (List<?>) event.getData();
		if (dataList.isEmpty())
			throw new IllegalArgumentException("No Data provided");
		if (!dataList.stream().map(Object::getClass).allMatch(Association.class::equals))
			throw new IllegalArgumentException("The event must be a list of " + Association.class);
		
		final List<Association<?>> associations = (List<Association<?>>) dataList;
		if(!associations.stream().map(Object::getClass).allMatch(associations.get(0).getRel()::equals))
			throw new IllegalArgumentException("Associations must be of same Relation");
		
		final Buerger_.Rel rel = Buerger_.Rel.valueOf(associations.get(0).getRel());
		
		if (Buerger_.Rel.kinder == rel) {
			List<Buerger_> kinder = associations.stream()
				.map(association -> (Buerger_) association.getAssociation())
				.collect(Collectors.toList());
			releaseKinderList(kinder);
			kinder.forEach(getModel().getSelectedBuergerKinder()::removeItem);
		}
		if (Buerger_.Rel.sachbearbeiter == rel) {
			List<Sachbearbeiter_> sachbearbeiter = associations.stream()
				.map(association -> (Sachbearbeiter_) association.getAssociation())
				.collect(Collectors.toList());
			releaseSachbearbeiterList(sachbearbeiter);
			sachbearbeiter.forEach(getModel().getSelectedBuergerSachbearbeiter()::removeItem);
		}
		notifyComponents();
	}
	
	/**
	 * Add the specified Associations to the specified Relation and update the DataStore.
	 * <p>
	 * If the {@link Association#getAssociation()} has no {@link ResourceSupport#getId()} the Resouce will be created
	 * on the DataStore first.
	 * </p>
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Association} as {@link Event#getData()}.
	 */
	@SuppressWarnings("unchecked")
	private void addAssociations(Event<?> event) {
		final Object data = event.getData();
		if (data == null)
			throw new NullPointerException("Event data must not be null!");
		if (! (data instanceof List))
			throw new IllegalArgumentException("The event must be of " + List.class);
		
		final List<?> dataList = (List<?>) event.getData();
		if (dataList.isEmpty())
			throw new IllegalArgumentException("No Data provided");
		if (!dataList.stream().map(Object::getClass).allMatch(Association.class::equals))
			throw new IllegalArgumentException("The event must be a list of " + Association.class);
			
		final List<Association<?>> associations = (List<Association<?>>) dataList;
		if(!associations.stream().map(Association::getRel).allMatch(associations.get(0).getRel()::equals))
			throw new IllegalArgumentException("Associations must be of same Relation");
		
		final Buerger_.Rel rel = Buerger_.Rel.valueOf(associations.get(0).getRel());
		if (Buerger_.Rel.kinder == rel) {
			List<Buerger_> kinder = associations.stream()
				.map(association -> {
					Buerger_ nextKinder = (Buerger_) association.getAssociation();
					
					// If nextKinder has no ID he has to be created in the backend
					if(nextKinder.getId()==null){
						Class<?> clazz = association.getAssociation().getClass();
						if(clazz.equals(Buerger_.class)){
							nextKinder = buergerService.create(nextKinder);
						} else if(clazz.equals(Buerger_.class)) {
							nextKinder = buergerService.create((Buerger_)nextKinder);
						} else {
							throw new IllegalArgumentException("Only classes \"? extends Buerger_\" allowed!");
						}
					}
					return nextKinder;
				}).collect(Collectors.toList());
			
			addBuergerKinderList(kinder);
			getModel().getSelectedBuergerKinder().addAll(kinder);
		}
		if (Buerger_.Rel.sachbearbeiter == rel) {
			List<Sachbearbeiter_> sachbearbeiter = associations.stream()
				.map(association -> {
					Sachbearbeiter_ nextSachbearbeiter = (Sachbearbeiter_) association.getAssociation();
					
					// If nextSachbearbeiter has no ID he has to be created in the backend
					if(nextSachbearbeiter.getId()==null){
						Class<?> clazz = association.getAssociation().getClass();
						if(clazz.equals(Sachbearbeiter_.class)){
							nextSachbearbeiter = sachbearbeiterService.create(nextSachbearbeiter);
						} else if(clazz.equals(Sachbearbeiter_.class)) {
							nextSachbearbeiter = sachbearbeiterService.create((Sachbearbeiter_)nextSachbearbeiter);
						} else {
							throw new IllegalArgumentException("Only classes \"? extends Sachbearbeiter_\" allowed!");
						}
					}
					return nextSachbearbeiter;
				}).collect(Collectors.toList());
			
			addBuergerSachbearbeiterList(sachbearbeiter);
			getModel().getSelectedBuergerSachbearbeiter().addAll(sachbearbeiter);
		}
		refreshModelAssociations();
		notifyComponents();
	}

	/**	
	 * Create a new Buerger on the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Buerger_} as {@link Event#getData()}.
	 */
	private void create(Event<?> event) {
		final Object data = event.getData();
		if (data == null) 
			throw new NullPointerException("Event data must not be null!");
		if (!(data instanceof Buerger_))
			throw new IllegalArgumentException("The event must be of " + Buerger_.class);
		final Buerger_ buerger = (Buerger_) event.getData();
		final Buerger_ fromREST = buergerService.create(buerger);
		getModel().getBuergers().addBean(fromREST);
		notifyComponents();
	}


	/**
	 * Delete the Buerger_ on the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Buerger_} as {@link Event#getData()}.
	 */
	private void delete(Event<?> event) {
		final Object data = event.getData();
		if (data == null) 
			throw new NullPointerException("Event data must not be null!");
		if (!(data instanceof Buerger_))
			throw new IllegalArgumentException("The event must be of " + Buerger_.class);
		final Buerger_ buerger = (Buerger_) event.getData();
		if (buerger.getId() == null)
			throw new IllegalArgumentException("The Buerger_ must have an ID.");
		buergerService.delete(buerger.getId());
		getModel().getSelectedBuerger().ifPresent(selectedBuerger -> {
			if (selectedBuerger.equals(buerger)) {
				getModel().setSelectedBuerger(null);
				// reset all selected relations
				getModel().getSelectedBuergerKinder().removeAllItems();
				getModel().setSelectedBuergerPartner(Optional.empty());
				getModel().setSelectedBuergerPass(Optional.empty());
				getModel().getSelectedBuergerSachbearbeiter().removeAllItems();
				getModel().setSelectedBuergerWohnungen(Optional.empty());
			}
		});
		getModel().getBuergers().removeItem(buerger);
		notifyComponents();
	}

	/**
	 * Update the Buerger_ on the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Buerger_} as {@link Event#getData()}.
	 */
	private void update(Event<?> event) {
		final Object data = event.getData();	 
		if (data == null) 
			throw new NullPointerException("Event data must not be null!");
		if (!(data instanceof Buerger_))
			throw new IllegalArgumentException("The event must be of " + Buerger_.class);
		final Buerger_ buerger = (Buerger_) event.getData();
		if (buerger.getId() == null)
			throw new IllegalArgumentException("The Buerger_ must have an ID.");
		final Buerger_ fromREST = buergerService.update(buerger);
		refreshModelSelected();
		getModel().getBuergers().addBean(fromREST);
		notifyComponents();
	}

	/**
	 * Refresh the {@link Buerger_Datastore#buergers} list from the DataStore.
	 * <p/>	
	 * <p>
	 * This method also filters by the query (ifPresent).
	 * </p>
	 */
	private void refreshModelList() {
		final Optional<String> query = getModel().getQuery();
		if (query.isPresent()) {
			getModel().getBuergers().removeAllItems();
			getModel().getBuergers().addAll(queryBuerger(query.get()));
		} else {
			getModel().getBuergers().removeAllItems();
			getModel().getBuergers().addAll(queryBuerger());
		}
	}

	/**
	 * Refresh *all* the associations of the selected Buerger_ in the model.
	 */
	void refreshModelAssociations() {
		getModel().getSelectedBuerger().ifPresent(buerger -> {
			final List<Buerger_> kinder = queryKinder(buerger);
			final Buerger_ partner = queryPartner(buerger);
			final Pass_ pass = queryPass(buerger);
			final List<Sachbearbeiter_> sachbearbeiter = querySachbearbeiter(buerger);
			final Wohnung_ wohnungen = queryWohnungen(buerger);
			getModel().getSelectedBuergerKinder().removeAllItems();
			getModel().getSelectedBuergerKinder().addAll(kinder);
			getModel().setSelectedBuergerPartner(Optional.ofNullable(partner));
			getModel().setSelectedBuergerPass(Optional.ofNullable(pass));
			getModel().getSelectedBuergerSachbearbeiter().removeAllItems();
			getModel().getSelectedBuergerSachbearbeiter().addAll(sachbearbeiter);
			getModel().setSelectedBuergerWohnungen(Optional.ofNullable(wohnungen));
		});	
	}

	/**
	 * Refresh the current selected Buerger_, but *not* its associations.
	 */
	private void refreshModelSelected() {
		getModel().getSelectedBuerger().ifPresent(buerger -> getModel().setSelectedBuerger(buergerService.findOne(buerger.getId()).orElse(null)));
	}

	/**	
	 * Set the query based on the String sent in the Event.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with a {@link String} query as {@link Event#getData()}.
	 */
	private void readList(Event<?> event) {
		final Object data = event.getData();

		if (data instanceof String) {
			final String filter = (String) event.getData();
			getModel().setQuery(filter);
		} else {
			getModel().setQuery(null);
		}

		refreshModelList();
		notifyComponents();
	}

	/**
	 * Read the Buerger_ in the Event from the DataStore and set it as the current selected Buerger_.
	 * If called with null, the current selected Buerger_ will only be refreshed from the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Buerger_} or *null* as {@link Event#getData()}.
	 */
	private void readSelected(Event<?> event) {
		final Object data = event.getData();

		if (data instanceof Buerger_) {
			final Buerger_ buerger = (Buerger_) event.getData();
			getModel().setSelectedBuerger(buerger);
			refreshModelSelected();
			refreshModelAssociations();
		} else if (data == null) {
			refreshModelSelected();
			refreshModelAssociations();
		} else {
			throw new IllegalArgumentException("The event cannot be of Class " + event.getData().getClass());
		}
		notifyComponents();
    }

	/**
	 * Notify all the Components.
	 */
	public void notifyComponents() {
		getEventbus().notify(getResponseKey(), Event.wrap(getModel()));
	}

	/**
	 * Get the RequestEntityKey for this Entity.
	 *
	 * @param event The disered event the Key will have.
	 * @return The RequestEntityKey with the chosen RequestEvent.
	 */
	public RequestEntityKey getRequestKey(RequestEvent event) {
		return new RequestEntityKey(event, Buerger_.class);
	}

	/**
	 * Get the ResponseEntityKey for this Entity.
	 *
	 * @return The ResponseEntityKey.
	 */
	public ResponseEntityKey getResponseKey() {
		return new ResponseEntityKey(Buerger_.class);
	}
}
