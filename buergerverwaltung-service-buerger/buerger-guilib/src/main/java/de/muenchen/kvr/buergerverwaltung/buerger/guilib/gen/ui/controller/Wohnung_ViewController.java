package de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.ui.controller;

import com.vaadin.spring.annotation.SpringComponent;
import com.vaadin.spring.annotation.UIScope;

import de.muenchen.eventbus.EventBus;
import de.muenchen.eventbus.events.Association;
import de.muenchen.eventbus.selector.entity.RequestEntityKey;
import de.muenchen.eventbus.selector.entity.RequestEvent;
import de.muenchen.eventbus.selector.entity.ResponseEntityKey;

import de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.services.Wohnung_Service;
import de.muenchen.kvr.buergerverwaltung.buerger.client.local.Wohnung_;
import de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.services.Adresse_Service;
import de.muenchen.kvr.buergerverwaltung.buerger.client.local.Adresse_;
import de.muenchen.kvr.buergerverwaltung.buerger.guilib.gen.services.model.Wohnung_Datastore;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.hateoas.ResourceSupport;
import org.springframework.hateoas.Link;
import reactor.bus.Event;

import javax.annotation.PostConstruct;
import java.io.Serializable;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import de.muenchen.vaadin.guilib.BaseUI;

/*
 * This file will be overwritten on every change of the model!
 * This file was automatically generated by GAIA.
 */
@SpringComponent
@UIScope
public class Wohnung_ViewController implements Serializable{

	private static final long serialVersionUID = 1L;
	
	/**
	 * Logger
	 */
	private static final Logger LOG = LoggerFactory.getLogger(Wohnung_ViewController.class);
	
	/**
	 * Die Wohnung_Service Klasse
	 */
	@Autowired
	Wohnung_Service wohnungService;
	
	/**
	 * Die Adresse_Service Klasse
	 */
	@Autowired
	Adresse_Service adresseService;
	
	private final Wohnung_Datastore model = new Wohnung_Datastore();
	

	@PostConstruct
	private void init() {
		initEventhandlers();
	}
	
	private EventBus getEventbus() {
        return BaseUI.getCurrentEventBus();
    }
	
	public Wohnung_Datastore getModel() {
		return model;
	}

	////////////////////////
	// Service Operations //
	////////////////////////

	/**
	 * Speichert ein {@link Wohnung_} Objekt in der Datenbank.
	 *
	 * @param wohnung Wohnung_ der gespeichert werden soll
	 */
	public Wohnung_ save(Wohnung_ wohnung) {
		return wohnungService.create(wohnung);
	}

	/**
	 * Zerstört die Verbindung zwischen einem Wohnung_ und seinem adresse
	 *
	 * @param event
	 */
	private void releaseAdresse(Adresse_ event) {
		Link link = getModel().getSelectedWohnung().get().getLink(Wohnung_.Rel.adresse.name());
		List<Link> adresse = adresseService.findAll(link)
				.stream()
				.map(Adresse_::getId)
				.filter(id -> !id.equals(event.getId()))
				.collect(Collectors.toList());

		wohnungService.setRelations(link, adresse);
	}
	
	/**
	 * Zerstört die Verbindung zwischen einem Wohnung_ und seinen adresse
	 *
	 * @param event
	 */
	private void releaseAdresseList(List<Adresse_> event) {
		Link link = getModel().getSelectedWohnung().get().getLink(Wohnung_.Rel.adresse.name());
		
		List<Link> eventLinks = event.stream().map(ResourceSupport::getId).collect(Collectors.toList());
		
		List<Link> relations = adresseService.findAll(link)
				.stream()
				.map(Adresse_::getId)
				.filter(id -> !eventLinks.contains(id))
				.collect(Collectors.toList());
		
		wohnungService.setRelations(link, relations);
	}
	
	/**
	 * Speichert eine beziehung als adresse zu einem {@link Adresse_} Objekt in der Datenbank.
	 *
	 * @param adresseEntity Adresse
	 * @return Adresse_
	 */
	public void addWohnungAdresse(Adresse_ adresseEntity) {
		Link link = getModel().getSelectedWohnung().get().getLink(Wohnung_.Rel.adresse.name());
		List<Link> adresselist = Stream.concat(
				adresseService.findAll(link)
						.stream()
						.map(Adresse_::getId),
				Stream.of(adresseEntity.getId()))
	
				.collect(Collectors.toList());
	
		wohnungService.setRelations(link, adresselist);
	}
	
	public List<Adresse_> queryAdresse(Wohnung_ entity) {
		return adresseService.findAll(entity.getLink(Wohnung_.Rel.adresse.name())).stream().collect(Collectors.toList());
	}
	
	/**
	 * Speichert Beziehungen als adresse zu einem {@link Adresse_} Objekt in der Datenbank.
	 *
	 * @param event Attributes
	 */
	public void addWohnungAdresseList(List<Adresse_> event) {
		Link link = getModel().getSelectedWohnung().get().getLink(Wohnung_.Rel.adresse.name());
		
		List<Link> eventLinks = event.stream().map(ResourceSupport::getId).collect(Collectors.toList());
		
		List<Link> relations = Stream.concat(
		wohnungService.findAll(link)
				.stream()
				.map(Wohnung_::getId)
				.filter(link1 -> !eventLinks.contains(link1)),
		
		eventLinks.stream())
				.collect(Collectors.toList());
		
		wohnungService.setRelations(link, relations);
	}
	/**
	 * Speichert die Änderungen an einem {@link Wohnung_} Objekt in der Datenbank.
	 *
	 * @param entity Wohnung_
	 * @return Wohnung_
	 */
	public Wohnung_ updateWohnung(Wohnung_ entity) {
		return wohnungService.update(entity);
	}

	/**
	 * Löscht ein {@link Wohnung_} Objekt.
	 *
	 * @param entity Wohnung_
	 */
	public void deleteWohnung(Wohnung_ entity) {
		wohnungService.delete(entity.getId());
	}

	public List<Wohnung_> queryWohnung() {
		return wohnungService.findAll().stream().collect(Collectors.toList());
	}

	public List<Wohnung_> queryWohnung(String query) {
		return wohnungService.queryWohnung(query);
	}
	
	/////////////////////
	// Event Steuerung //
	/////////////////////

	/**
	 * Register all event handlers on the RequestEntityKey.
	 */
	private void initEventhandlers() {
		getEventbus().on(getRequestKey(RequestEvent.CREATE).toSelector(), this::create);
		getEventbus().on(getRequestKey(RequestEvent.DELETE).toSelector(), this::delete);	 
		getEventbus().on(getRequestKey(RequestEvent.UPDATE).toSelector(), this::update);
		getEventbus().on(getRequestKey(RequestEvent.ADD_ASSOCIATION).toSelector(), this::addAssociation);	 
		getEventbus().on(getRequestKey(RequestEvent.REMOVE_ASSOCIATION).toSelector(), this::removeAssociation);
		getEventbus().on(getRequestKey(RequestEvent.ADD_ASSOCIATIONS).toSelector(), this::addAssociations);
		getEventbus().on(getRequestKey(RequestEvent.REMOVE_ASSOCIATIONS).toSelector(), this::removeAssociations);
		getEventbus().on(getRequestKey(RequestEvent.READ_LIST).toSelector(), this::readList);
		getEventbus().on(getRequestKey(RequestEvent.READ_SELECTED).toSelector(), this::readSelected);
	}

	/**
	 * Remove the specified Association from the specified Relation and update the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Association} as {@link Event#getData()}.
	 */
	void removeAssociation(Event<?> event) {
		final Object data = event.getData();
		if (data == null)
			throw new NullPointerException("Event data must not be null!");
		if (data.getClass() != Association.class)
			throw new IllegalArgumentException("The event must be of " + Association.class);

		final Association<?> association = (Association<?>) event.getData();
		final Wohnung_.Rel rel = Wohnung_.Rel.valueOf(association.getRel());
		
		if (Wohnung_.Rel.adresse == rel) {
			Adresse_ adresse = (Adresse_) association.getAssociation();
			releaseAdresse(adresse);
			getModel().getSelectedWohnungAdresse().removeItem(adresse);
		}
		notifyComponents();
	}

	/**
	 * Add the specified Association to the specified Relation and update the DataStore.
	 * <p>	 
	 * If the {@link Association#getAssociation()} has no {@link ResourceSupport#getId()} the Resouce will be created
	 * on the DataStore first.
	 * </p>
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Association} as {@link Event#getData()}.
	 */
	private void addAssociation(Event<?> event) {
		final Object data = event.getData();
		if (data == null) 
			throw new NullPointerException("Event data must not be null!");
		if (data.getClass() != Association.class)
			throw new IllegalArgumentException("The event must be of " + Association.class);

		final Association<?> association = (Association<?>) event.getData();

		final Wohnung_.Rel rel = Wohnung_.Rel.valueOf(association.getRel());
		if (Wohnung_.Rel.adresse == rel) {
			Adresse_ adresse = (Adresse_) association.getAssociation();
			// If Adresse has no ID he has to be created in the backend
			if (adresse.getId() == null) {
				Class<?> clazz = association.getAssociation().getClass();
				if(clazz.equals(Adresse_.class)){
					adresse = adresseService.create((Adresse_)association.getAssociation());
				} else if(clazz.equals(Adresse_.class)){
					adresse = adresseService.create((Adresse_) association.getAssociation());
				} else{
					throw new IllegalArgumentException("Only classes \"? extends Adresse_\" allowed!");
				}
			}
			addWohnungAdresse(adresse);
			getModel().getSelectedWohnungAdresse().addBean(adresse);
		}
		refreshModelAssociations();
		notifyComponents();
	}
	
	/**
	 * Remove the specified Associations from the specified Relation and update the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Association} as {@link Event#getData()}.
	 */
	@SuppressWarnings("unchecked")
	void removeAssociations(Event<?> event) {
		final Object data = event.getData();
		if (data == null)
			throw new NullPointerException("Event data must not be null!");
		if (!(data instanceof List))
			throw new IllegalArgumentException("The event must be of " + List.class);
		
		final List<?> dataList = (List<?>) event.getData();
		if (dataList.isEmpty())
			throw new IllegalArgumentException("No Data provided");
		if (!dataList.stream().map(Object::getClass).allMatch(Association.class::equals))
			throw new IllegalArgumentException("The event must be a list of " + Association.class);
		
		final List<Association<?>> associations = (List<Association<?>>) dataList;
		if(!associations.stream().map(Object::getClass).allMatch(associations.get(0).getRel()::equals))
			throw new IllegalArgumentException("Associations must be of same Relation");
		
		final Wohnung_.Rel rel = Wohnung_.Rel.valueOf(associations.get(0).getRel());
		
		if (Wohnung_.Rel.adresse == rel) {
			List<Adresse_> adresse = associations.stream()
				.map(association -> (Adresse_) association.getAssociation())
				.collect(Collectors.toList());
			releaseAdresseList(adresse);
			adresse.forEach(getModel().getSelectedWohnungAdresse()::removeItem);
		}
		notifyComponents();
	}
	
	/**
	 * Add the specified Associations to the specified Relation and update the DataStore.
	 * <p>
	 * If the {@link Association#getAssociation()} has no {@link ResourceSupport#getId()} the Resouce will be created
	 * on the DataStore first.
	 * </p>
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Association} as {@link Event#getData()}.
	 */
	@SuppressWarnings("unchecked")
	private void addAssociations(Event<?> event) {
		final Object data = event.getData();
		if (data == null)
			throw new NullPointerException("Event data must not be null!");
		if (! (data instanceof List))
			throw new IllegalArgumentException("The event must be of " + List.class);
		
		final List<?> dataList = (List<?>) event.getData();
		if (dataList.isEmpty())
			throw new IllegalArgumentException("No Data provided");
		if (!dataList.stream().map(Object::getClass).allMatch(Association.class::equals))
			throw new IllegalArgumentException("The event must be a list of " + Association.class);
			
		final List<Association<?>> associations = (List<Association<?>>) dataList;
		if(!associations.stream().map(Association::getRel).allMatch(associations.get(0).getRel()::equals))
			throw new IllegalArgumentException("Associations must be of same Relation");
		
		final Wohnung_.Rel rel = Wohnung_.Rel.valueOf(associations.get(0).getRel());
		if (Wohnung_.Rel.adresse == rel) {
			List<Adresse_> adresse = associations.stream()
				.map(association -> {
					Adresse_ nextAdresse = (Adresse_) association.getAssociation();
					
					// If nextAdresse has no ID he has to be created in the backend
					if(nextAdresse.getId()==null){
						Class<?> clazz = association.getAssociation().getClass();
						if(clazz.equals(Adresse_.class)){
							nextAdresse = adresseService.create(nextAdresse);
						} else if(clazz.equals(Adresse_.class)) {
							nextAdresse = adresseService.create((Adresse_)nextAdresse);
						} else {
							throw new IllegalArgumentException("Only classes \"? extends Adresse_\" allowed!");
						}
					}
					return nextAdresse;
				}).collect(Collectors.toList());
			
			addWohnungAdresseList(adresse);
			getModel().getSelectedWohnungAdresse().addAll(adresse);
		}
		refreshModelAssociations();
		notifyComponents();
	}

	/**	
	 * Create a new Buerger on the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Wohnung_} as {@link Event#getData()}.
	 */
	private void create(Event<?> event) {
		final Object data = event.getData();
		if (data == null) 
			throw new NullPointerException("Event data must not be null!");
		if (!(data instanceof Wohnung_))
			throw new IllegalArgumentException("The event must be of " + Wohnung_.class);
		final Wohnung_ wohnung = (Wohnung_) event.getData();
		final Wohnung_ fromREST = wohnungService.create(wohnung);
		getModel().getWohnungs().addBean(fromREST);
		notifyComponents();
	}


	/**
	 * Delete the Wohnung_ on the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Wohnung_} as {@link Event#getData()}.
	 */
	private void delete(Event<?> event) {
		final Object data = event.getData();
		if (data == null) 
			throw new NullPointerException("Event data must not be null!");
		if (!(data instanceof Wohnung_))
			throw new IllegalArgumentException("The event must be of " + Wohnung_.class);
		final Wohnung_ wohnung = (Wohnung_) event.getData();
		if (wohnung.getId() == null)
			throw new IllegalArgumentException("The Wohnung_ must have an ID.");
		wohnungService.delete(wohnung.getId());
		getModel().getSelectedWohnung().ifPresent(selectedWohnung -> {
			if (selectedWohnung.equals(wohnung)) {
				getModel().setSelectedWohnung(null);
				// reset all selected relations
				getModel().getSelectedWohnungAdresse().removeAllItems();
			}
		});
		getModel().getWohnungs().removeItem(wohnung);
		notifyComponents();
	}

	/**
	 * Update the Wohnung_ on the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Wohnung_} as {@link Event#getData()}.
	 */
	private void update(Event<?> event) {
		final Object data = event.getData();	 
		if (data == null) 
			throw new NullPointerException("Event data must not be null!");
		if (!(data instanceof Wohnung_))
			throw new IllegalArgumentException("The event must be of " + Wohnung_.class);
		final Wohnung_ wohnung = (Wohnung_) event.getData();
		if (wohnung.getId() == null)
			throw new IllegalArgumentException("The Wohnung_ must have an ID.");
		final Wohnung_ fromREST = wohnungService.update(wohnung);
		refreshModelSelected();
		getModel().getWohnungs().addBean(fromREST);
		notifyComponents();
	}

	/**
	 * Refresh the {@link Wohnung_Datastore#wohnungs} list from the DataStore.
	 * <p/>	
	 * <p>
	 * This method also filters by the query (ifPresent).
	 * </p>
	 */
	private void refreshModelList() {
		final Optional<String> query = getModel().getQuery();
		if (query.isPresent()) {
			getModel().getWohnungs().removeAllItems();
			getModel().getWohnungs().addAll(queryWohnung(query.get()));
		} else {
			getModel().getWohnungs().removeAllItems();
			getModel().getWohnungs().addAll(queryWohnung());
		}
	}

	/**
	 * Refresh *all* the associations of the selected Wohnung_ in the model.
	 */
	void refreshModelAssociations() {
		getModel().getSelectedWohnung().ifPresent(wohnung -> {
			final List<Adresse_> adresse = queryAdresse(wohnung);
			getModel().getSelectedWohnungAdresse().removeAllItems();
			getModel().getSelectedWohnungAdresse().addAll(adresse);
		});	
	}

	/**
	 * Refresh the current selected Wohnung_, but *not* its associations.
	 */
	private void refreshModelSelected() {
		getModel().getSelectedWohnung().ifPresent(wohnung -> getModel().setSelectedWohnung(wohnungService.findOne(wohnung.getId()).orElse(null)));
	}

	/**	
	 * Set the query based on the String sent in the Event.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with a {@link String} query as {@link Event#getData()}.
	 */
	private void readList(Event<?> event) {
		final Object data = event.getData();

		if (data instanceof String) {
			final String filter = (String) event.getData();
			getModel().setQuery(filter);
		} else {
			getModel().setQuery(null);
		}

		refreshModelList();
		notifyComponents();
	}

	/**
	 * Read the Wohnung_ in the Event from the DataStore and set it as the current selected Wohnung_.
	 * If called with null, the current selected Wohnung_ will only be refreshed from the DataStore.
	 * Update the Model and send it on the ResponseEntityKey if necessary.
	 *
	 * @param event The event with an {@link Wohnung_} or *null* as {@link Event#getData()}.
	 */
	private void readSelected(Event<?> event) {
		final Object data = event.getData();

		if (data instanceof Wohnung_) {
			final Wohnung_ wohnung = (Wohnung_) event.getData();
			getModel().setSelectedWohnung(wohnung);
			refreshModelSelected();
			refreshModelAssociations();
		} else if (data == null) {
			refreshModelSelected();
			refreshModelAssociations();
		} else {
			throw new IllegalArgumentException("The event cannot be of Class " + event.getData().getClass());
		}
		notifyComponents();
    }

	/**
	 * Notify all the Components.
	 */
	public void notifyComponents() {
		getEventbus().notify(getResponseKey(), Event.wrap(getModel()));
	}

	/**
	 * Get the RequestEntityKey for this Entity.
	 *
	 * @param event The disered event the Key will have.
	 * @return The RequestEntityKey with the chosen RequestEvent.
	 */
	public RequestEntityKey getRequestKey(RequestEvent event) {
		return new RequestEntityKey(event, Wohnung_.class);
	}

	/**
	 * Get the ResponseEntityKey for this Entity.
	 *
	 * @return The ResponseEntityKey.
	 */
	public ResponseEntityKey getResponseKey() {
		return new ResponseEntityKey(Wohnung_.class);
	}
}
